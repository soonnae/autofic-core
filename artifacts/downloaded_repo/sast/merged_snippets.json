[
  {
    "input": "module.exports = {\n  username: process.env.MYSQL_USER,\n  password: process.env.MYSQL_PASSWORD,\n  database: process.env.MYSQL_DATABASE,\n  host: process.env.MYSQL_HOST || 'mysql-db',\n  port: process.env.MYSQL_PORT || 3306,\n  dialect: 'mysql'\n}",
    "idx": null,
    "start_line": 1,
    "end_line": 8,
    "snippet": "  database: process.env.MYSQL_DATABASE,\n  dialect: 'mysql'\n  host: process.env.MYSQL_HOST || 'mysql-db',\n  password: process.env.MYSQL_PASSWORD,\n  port: process.env.MYSQL_PORT || 3306,\n  username: process.env.MYSQL_USER,\nmodule.exports = {\n}",
    "message": "If TLS is disabled on server side (Postgresql server), Sequelize establishes connection without TLS and no error will be thrown. To prevent MITN (Man In The Middle) attack, TLS must be enforce by Sequelize. Set \"ssl: true\" or define settings \"ssl: {...}\"",
    "vulnerability_class": [
      "Mishandled Sensitive Information"
    ],
    "cwe": [
      "CWE-319: Cleartext Transmission of Sensitive Information"
    ],
    "severity": "WARNING",
    "references": [
      "https://node-postgres.com/features/ssl",
      "https://nodejs.org/api/tls.html#tls_class_tls_tlssocket",
      "https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options",
      "https://nodejs.org/api/tls.html#tls_tls_default_min_version"
    ],
    "path": "config/db.js"
  },
  {
    "input": "var db = require('../models')\nvar bCrypt = require('bcrypt')\nconst exec = require('child_process').exec;\nvar mathjs = require('mathjs')\nvar libxmljs = require(\"libxmljs\");\nvar serialize = require(\"node-serialize\")\nconst Op = db.Sequelize.Op\n\nmodule.exports.userSearch = function (req, res) {\n\tvar query = \"SELECT name,id FROM Users WHERE login='\" + req.body.login + \"'\";\n\tdb.sequelize.query(query, {\n\t\tmodel: db.User\n\t}).then(user => {\n\t\tif (user.length) {\n\t\t\tvar output = {\n\t\t\t\tuser: {\n\t\t\t\t\tname: user[0].name,\n\t\t\t\t\tid: user[0].id\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('warning', 'User not found')\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: null\n\t\t\t})\n\t\t}\n\t}).catch(err => {\n\t\treq.flash('danger', 'Internal Error')\n\t\tres.render('app/usersearch', {\n\t\t\toutput: null\n\t\t})\n\t})\n}\n\nmodule.exports.ping = function (req, res) {\n\texec('ping -c 2 ' + req.body.address, function (err, stdout, stderr) {\n\t\toutput = stdout + stderr\n\t\tres.render('app/ping', {\n\t\t\toutput: output\n\t\t})\n\t})\n}\n\nmodule.exports.listProducts = function (req, res) {\n\tdb.Product.findAll().then(products => {\n\t\toutput = {\n\t\t\tproducts: products\n\t\t}\n\t\tres.render('app/products', {\n\t\t\toutput: output\n\t\t})\n\t})\n}\n\nmodule.exports.productSearch = function (req, res) {\n\tdb.Product.findAll({\n\t\twhere: {\n\t\t\tname: {\n\t\t\t\t[Op.like]: '%' + req.body.name + '%'\n\t\t\t}\n\t\t}\n\t}).then(products => {\n\t\toutput = {\n\t\t\tproducts: products,\n\t\t\tsearchTerm: req.body.name\n\t\t}\n\t\tres.render('app/products', {\n\t\t\toutput: output\n\t\t})\n\t})\n}\n\nmodule.exports.modifyProduct = function (req, res) {\n\tif (!req.query.id || req.query.id == '') {\n\t\toutput = {\n\t\t\tproduct: {}\n\t\t}\n\t\tres.render('app/modifyproduct', {\n\t\t\toutput: output\n\t\t})\n\t} else {\n\t\tdb.Product.find({\n\t\t\twhere: {\n\t\t\t\t'id': req.query.id\n\t\t\t}\n\t\t}).then(product => {\n\t\t\tif (!product) {\n\t\t\t\tproduct = {}\n\t\t\t}\n\t\t\toutput = {\n\t\t\t\tproduct: product\n\t\t\t}\n\t\t\tres.render('app/modifyproduct', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t})\n\t}\n}\n\nmodule.exports.modifyProductSubmit = function (req, res) {\n\tif (!req.body.id || req.body.id == '') {\n\t\treq.body.id = 0\n\t}\n\tdb.Product.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\n\t}).then(product => {\n\t\tif (!product) {\n\t\t\tproduct = new db.Product()\n\t\t}\n\t\tproduct.code = req.body.code\n\t\tproduct.name = req.body.name\n\t\tproduct.description = req.body.description\n\t\tproduct.tags = req.body.tags\n\t\tproduct.save().then(p => {\n\t\t\tif (p) {\n\t\t\t\treq.flash('success', 'Product added/modified!')\n\t\t\t\tres.redirect('/app/products')\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\toutput = {\n\t\t\t\tproduct: product\n\t\t\t}\n\t\t\treq.flash('danger',err)\n\t\t\tres.render('app/modifyproduct', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t})\n\t})\n}\n\nmodule.exports.userEdit = function (req, res) {\n\tres.render('app/useredit', {\n\t\tuserId: req.user.id,\n\t\tuserEmail: req.user.email,\n\t\tuserName: req.user.name\n\t})\n}\n\nmodule.exports.userEditSubmit = function (req, res) {\n\tdb.User.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\t\t\n\t}).then(user =>{\n\t\tif(req.body.password.length>0){\n\t\t\tif(req.body.password.length>0){\n\t\t\t\tif (req.body.password == req.body.cpassword) {\n\t\t\t\t\tuser.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n\t\t\t\t}else{\n\t\t\t\t\treq.flash('warning', 'Passwords dont match')\n\t\t\t\t\tres.render('app/useredit', {\n\t\t\t\t\t\tuserId: req.user.id,\n\t\t\t\t\t\tuserEmail: req.user.email,\n\t\t\t\t\t\tuserName: req.user.name,\n\t\t\t\t\t})\n\t\t\t\t\treturn\t\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treq.flash('warning', 'Invalid Password')\n\t\t\t\tres.render('app/useredit', {\n\t\t\t\t\tuserId: req.user.id,\n\t\t\t\t\tuserEmail: req.user.email,\n\t\t\t\t\tuserName: req.user.name,\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tuser.email = req.body.email\n\t\tuser.name = req.body.name\n\t\tuser.save().then(function () {\n\t\t\treq.flash('success',\"Updated successfully\")\n\t\t\tres.render('app/useredit', {\n\t\t\t\tuserId: req.body.id,\n\t\t\t\tuserEmail: req.body.email,\n\t\t\t\tuserName: req.body.name,\n\t\t\t})\n\t\t})\n\t})\n}\n\nmodule.exports.redirect = function (req, res) {\n\tif (req.query.url) {\n\t\tres.redirect(req.query.url)\n\t} else {\n\t\tres.send('invalid redirect url')\n\t}\n}\n\nmodule.exports.calc = function (req, res) {\n\tif (req.body.eqn) {\n\t\tres.render('app/calc', {\n\t\t\toutput: mathjs.eval(req.body.eqn)\n\t\t})\n\t} else {\n\t\tres.render('app/calc', {\n\t\t\toutput: 'Enter a valid math string like (3+3)*2'\n\t\t})\n\t}\n}\n\nmodule.exports.listUsersAPI = function (req, res) {\n\tdb.User.findAll({}).then(users => {\n\t\tres.status(200).json({\n\t\t\tsuccess: true,\n\t\t\tusers: users\n\t\t})\n\t})\n}\n\nmodule.exports.bulkProductsLegacy = function (req,res){\n\t// TODO: Deprecate this soon\n\tif(req.files.products){\n\t\tvar products = serialize.unserialize(req.files.products.data.toString('utf8'))\n\t\tproducts.forEach( function (product) {\n\t\t\tvar newProduct = new db.Product()\n\t\t\tnewProduct.name = product.name\n\t\t\tnewProduct.code = product.code\n\t\t\tnewProduct.tags = product.tags\n\t\t\tnewProduct.description = product.description\n\t\t\tnewProduct.save()\n\t\t})\n\t\tres.redirect('/app/products')\n\t}else{\n\t\tres.render('app/bulkproducts',{messages:{danger:'Invalid file'},legacy:true})\n\t}\n}\n\nmodule.exports.bulkProducts =  function(req, res) {\n\tif (req.files.products && req.files.products.mimetype=='text/xml'){\n\t\tvar products = libxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:true,noblanks:true})\n\t\tproducts.root().childNodes().forEach( product => {\n\t\t\tvar newProduct = new db.Product()\n\t\t\tnewProduct.name = product.childNodes()[0].text()\n\t\t\tnewProduct.code = product.childNodes()[1].text()\n\t\t\tnewProduct.tags = product.childNodes()[2].text()\n\t\t\tnewProduct.description = product.childNodes()[3].text()\n\t\t\tnewProduct.save()\n\t\t})\n\t\tres.redirect('/app/products')\n\t}else{\n\t\tres.render('app/bulkproducts',{messages:{danger:'Invalid file'},legacy:false})\n\t}\n}\n",
    "idx": null,
    "start_line": 11,
    "end_line": 235,
    "snippet": "\t\tres.redirect(req.query.url)\n\t\tvar products = libxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:true,noblanks:true})\n\t\tvar products = serialize.unserialize(req.files.products.data.toString('utf8'))\n\tdb.sequelize.query(query, {",
    "message": "Detected a sequelize statement that is tainted by user-input. This could lead to SQL injection if the variable is user-controlled and is not properly sanitized. In order to prevent SQL injection, it is recommended to use parameterized queries or prepared statements. | The application redirects to a URL specified by user-supplied input `req` that is not validated. This could redirect users to malicious locations. Consider using an allow-list approach to validate URLs, or warn users they are being redirected to a third-party website. | The following function call serialize.unserialize accepts user controlled data which can result in Remote Code Execution (RCE) through Object Deserialization. It is recommended to use secure data processing alternatives such as JSON.parse() and Buffer.from(). | The libxml library processes user-input with the `noent` attribute is set to `true` which can lead to being vulnerable to XML External Entities (XXE) type attacks. It is recommended to set `noent` to `false` when using this feature to ensure you are protected.",
    "vulnerability_class": [
      "Insecure Deserialization ",
      "Open Redirect",
      "SQL Injection",
      "XML Injection"
    ],
    "cwe": [
      "CWE-502: Deserialization of Untrusted Data",
      "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')",
      "CWE-611: Improper Restriction of XML External Entity Reference",
      "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
    ],
    "severity": "ERROR",
    "references": [
      "https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html",
      "https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html",
      "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html",
      "https://sequelize.org/docs/v6/core-concepts/raw-queries/#replacements"
    ],
    "path": "core/appHandler.js"
  },
  {
    "input": "\"use strict\";\n\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar Sequelize = require(\"sequelize\");\nvar env = process.env.NODE_ENV || \"development\";\nvar config = require(\"../config/db.js\")\n\nif (process.env.DATABASE_URL) {\n  var sequelize = new Sequelize(process.env.DATABASE_URL);\n} else {\n  var sequelize = new Sequelize(config.database, config.username, config.password, {\n    host: config.host,\n    dialect: config.dialect\n  });\n}\n\nsequelize\n  .authenticate()\n  .then(function (err) {\n    console.log('Connection has been established successfully.');\n  })\n  .catch(function (err) {\n    console.log('Unable to connect to the database:', err);\n  })\n\nsequelize\n  .sync( /*{ force: true }*/ ) // Force To re-initialize tables on each run\n  .then(function (err) {\n    console.log('It worked!');\n  }, function (err) {\n    console.log('An error occurred while creating the table:', err);\n  })\n\nvar db = {};\n\nfs\n  .readdirSync(__dirname)\n  .filter(function (file) {\n    return (file.indexOf(\".\") !== 0) && (file !== \"index.js\");\n  })\n  .forEach(function (file) {\n    var model = sequelize.import(path.join(__dirname, file));\n    db[model.name] = model;\n  });\n\nObject.keys(db).forEach(function (modelName) {\n  if (\"associate\" in db[modelName]) {\n    db[modelName].associate(db);\n  }\n});\n\ndb.sequelize = sequelize;\ndb.Sequelize = Sequelize;\n\nmodule.exports = db;",
    "idx": null,
    "start_line": 43,
    "end_line": 43,
    "snippet": "    var model = sequelize.import(path.join(__dirname, file));",
    "message": "Detected possible user input going into a `path.join` or `path.resolve` function. This could possibly lead to a path traversal vulnerability,  where the attacker can access arbitrary files stored in the file system. Instead, be sure to sanitize or validate user input first.",
    "vulnerability_class": [
      "Path Traversal"
    ],
    "cwe": [
      "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
    ],
    "severity": "WARNING",
    "references": [
      "https://owasp.org/www-community/attacks/Path_Traversal"
    ],
    "path": "models/index.js"
  },
  {
    "input": "var express = require('express')\nvar bodyParser = require('body-parser')\nvar passport = require('passport')\nvar session = require('express-session')\nvar ejs = require('ejs')\nvar morgan = require('morgan')\nconst fileUpload = require('express-fileupload');\nvar config = require('./config/server')\n\n//Initialize Express\nvar app = express()\nrequire('./core/passport')(passport)\napp.use(express.static('public'))\napp.set('view engine','ejs')\napp.use(morgan('tiny'))\napp.use(bodyParser.urlencoded({ extended: false }))\napp.use(fileUpload());\n\n// Enable for Reverse proxy support\n// app.set('trust proxy', 1) \n\n// Intialize Session\napp.use(session({\n  secret: 'keyboard cat',\n  resave: true,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}))\n\n// Initialize Passport\napp.use(passport.initialize())\napp.use(passport.session())\n\n// Initialize express-flash\napp.use(require('express-flash')());\n\n// Routing\napp.use('/app',require('./routes/app')())\napp.use('/',require('./routes/main')(passport))\n\n// Start Server\napp.listen(config.port, config.listen)",
    "idx": null,
    "start_line": 11,
    "end_line": 28,
    "snippet": "  cookie: { secure: false }\n  resave: true,\n  saveUninitialized: true,\n  secret: 'keyboard cat',\napp.use(session({\nvar app = express()\n}))",
    "message": "A CSRF middleware was not detected in your express application. Ensure you are either using one such as `csurf` or `csrf` (see rule references) and/or you are properly doing CSRF validation in your routes with a token or cookies. | A hard-coded credential was detected. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module). | Default session middleware settings: `domain` not set. It indicates the domain of the cookie; use it to compare against the domain of the server in which the URL is being requested. If they match, then check the path attribute next. | Default session middleware settings: `expires` not set. Use it to set expiration date for persistent cookies. | Default session middleware settings: `httpOnly` not set. It ensures the cookie is sent only over HTTP(S), not client JavaScript, helping to protect against cross-site scripting attacks. | Default session middleware settings: `path` not set. It indicates the path of the cookie; use it to compare against the request path. If this and domain match, then send the cookie in the request. | Default session middleware settings: `secure` not set. It ensures the browser only sends the cookie over HTTPS. | Don’t use the default session cookie name Using the default session cookie name can open your app to attacks. The security issue posed is similar to X-Powered-By: a potential attacker can use it to fingerprint the server and target attacks accordingly.",
    "vulnerability_class": [
      "Cross-Site Request Forgery (CSRF)",
      "Cryptographic Issues",
      "Hard-coded Secrets"
    ],
    "cwe": [
      "CWE-352: Cross-Site Request Forgery (CSRF)",
      "CWE-522: Insufficiently Protected Credentials",
      "CWE-798: Use of Hard-coded Credentials"
    ],
    "severity": "WARNING",
    "references": [
      "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html",
      "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html",
      "https://owasp.org/Top10/A04_2021-Insecure_Design",
      "https://www.npmjs.com/package/csrf",
      "https://www.npmjs.com/package/csurf"
    ],
    "path": "server.js"
  }
]
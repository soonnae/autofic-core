[
  {
    "input": "// (C) 2016 Anton Zemlyanov, rewritten in JavaScript 6 (ES6)\n'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst url = require('url');\nconst zlib = require('zlib');\nconst Stream = require('stream');\nconst _ = require('lodash');\n\nconst cookieJar = require('./cookie_jar.js');\n\n// always used with BF API\nconst USE_GZIP_COMPRESSION = true;\nconst NANOSECONDS_IN_SECOND = 1000000000;\nconst MAX_REQUEST_TIMEOUT = 15*1000;\n\nconst agentParams = {keepAlive: true, maxFreeSockets: 8};\nconst httpAgent = new http.Agent(agentParams);\nconst httpsAgent = new https.Agent(agentParams);\n\nclass HttpRequest extends Stream {\n    // get http request\n    static get(url, options = {}, cb = () => {}) {\n        const opts = _.extend({\n            url: url,\n            method: 'get'\n        }, options);\n        return new HttpRequest(opts).execute(cb);\n    }\n\n    // post http request\n    static post(url, data, options = {}, cb = () => {}) {\n        const opts = _.extend({\n            url: url,\n            method: 'post',\n            requestBody: data\n        }, options);\n        return new HttpRequest(opts).execute(cb);\n    }\n\n    // constructor\n    constructor(options = {}) {\n        super();\n\n        // Stream stuff, HttpRequest is writable stream\n        this.readable = false;\n        this.writable = true;\n\n        this.options = options;\n        this.rawResponseLength = 0;\n        this.responseBody = '';\n        this.parsedUrl = url.parse(options.url);\n        this.method = options.method;\n    }\n\n    // do actual job\n    execute(cb = () => {\n    }) {\n        this.callback = cb;\n        const transport = this.parsedUrl.protocol === 'https:' ? https : http;\n        let httpOptions = {\n            agent: (this.parsedUrl.protocol === 'https:' ? httpsAgent : httpAgent),\n            host: this.parsedUrl.hostname,\n            port: this.parsedUrl.port,\n            path: this.parsedUrl.pathname,\n            method: this.method,\n            headers: this.options.headers || {},\n            rejectUnauthorized: false\n        };\n        _.extend(httpOptions.headers, this.options.headers);\n        httpOptions.headers.cookie = cookieJar.serialize();\n        if (USE_GZIP_COMPRESSION) {\n            httpOptions.headers['accept-encoding'] = 'gzip';\n        }\n        httpOptions.headers.cookie = cookieJar.serialize();\n\n        let request = transport.request(httpOptions, (result) => {\n            //console.log(\"statusCode: \", result.statusCode, \"headers: \", result.headers);\n            this.statusCode = result.statusCode;\n            this.contentType = result.headers['content-type'];\n            this.cookies = result.headers['set-cookie'];\n            cookieJar.parse(this.cookies);\n\n            // just for stats\n            result.on('data', (data) => {\n                this.rawResponseLength += data.length;\n            });\n            result.on('error', (err) => {\n                this.callback(err);\n            });\n\n            // http request input to self output\n            if (result.headers['content-encoding'] === 'gzip') {\n                // piping through gzip\n                let gunzip = zlib.createGunzip();\n                result.pipe(gunzip).pipe(this);\n            } else {\n                // piping directly to self\n                result.pipe(this);\n            }\n        });\n        request.on('error', (err) => {\n            this.callback(err);\n        });\n        // request.on('socket', function (socket) {\n        //     socket.setTimeout(MAX_REQUEST_TIMEOUT);\n        //     socket.on('timeout', function() {\n        //         request.abort();\n        //     });\n        // });\n        request.setTimeout(MAX_REQUEST_TIMEOUT, () => {\n            request.abort();\n            //this.callback('REQUEST_TIMEOUT');\n        });\n        if (this.method === 'post') {\n            request.write(this.options.requestBody);\n        }\n        this.startTime = process.hrtime();\n        request.end();\n    }\n\n    // http(s) chuck data\n    write(data) {\n        this.responseBody += data.toString();\n    }\n\n    // http(s) end of chunk data\n    end() {\n        // duration\n        this.endTime = process.hrtime();\n        let start = this.startTime[0] + (this.startTime[1] / NANOSECONDS_IN_SECOND);\n        let end = this.endTime[0] + (this.endTime[1] / NANOSECONDS_IN_SECOND);\n\n        // gzip compression efficiency\n        let responseBodyLength = this.responseBody.length;\n        let ratio = 100.0 - (this.rawResponseLength / responseBodyLength) * 100.0;\n        ratio = Math.round(ratio);\n\n        // if JSON, parse JSON into JS object\n        if (this.contentType === 'application/json') {\n            try {\n                this.responseBody = JSON.parse(this.responseBody);\n            } catch (error) {\n                this.responseBody = {\n                    error: 'Bad JSON'\n                };\n            }\n        }\n\n        this.callback(null, {\n            statusCode: this.statusCode,\n            contentType: this.contentType,\n            responseBody: this.responseBody,\n            cookies: this.cookies,\n            length: responseBodyLength,\n            compressionRation: ratio,\n            duration: Math.round((end - start) * 1000)\n        });\n    }\n}\nmodule.exports = HttpRequest;\n",
    "idx": null,
    "start_line": 62,
    "end_line": 70,
    "snippet": "            agent: (this.parsedUrl.protocol === 'https:' ? httpsAgent : httpAgent),\n            headers: this.options.headers || {},\n            host: this.parsedUrl.hostname,\n            method: this.method,\n            path: this.parsedUrl.pathname,\n            port: this.parsedUrl.port,\n            rejectUnauthorized: false\n        let httpOptions = {\n        };",
    "message": "Checks for setting the environment variable NODE_TLS_REJECT_UNAUTHORIZED to 0, which disables TLS verification. This should only be used for debugging purposes. Setting the option rejectUnauthorized to false bypasses verification against the list of trusted CAs, which also leads to insecure transport. These options lead to vulnerability to MTM attacks, and should not be used.",
    "vulnerability_class": [
      "Mishandled Sensitive Information"
    ],
    "cwe": [
      "CWE-319: Cleartext Transmission of Sensitive Information"
    ],
    "severity": "WARNING",
    "references": [
      "https://nodejs.org/api/https.html#https_https_request_options_callback",
      "https://stackoverflow.com/questions/20433287/node-js-request-cert-has-expired#answer-29397100"
    ],
    "path": "src/lib/http_request.js"
  }
]